<h3>

:eight_spoked_asterisk: 전역 변수의 무분별한 사용은 위험하므로 반드시 필요한 경우가 아니라면 지역 변수를 사용할 것 

    주제: 전역 변수의 문제점, 전역 변수의 사용을 어떻게 억제할 수 있는가?
</h3>

## :bulb: 변수의 생명 주기
- 변수의 생명 주기: 변수가 생성되고 소멸되기까지
    - 전역 변수의 생명 주기 === 어플리케이션의 생명 주기
    - 지역 변수의 생명 주기는 함수의 생명 주기와 대부분 일치
        - 일반적으로 함수가 종료되면 함수가 생성한 스코프도 종료되지만 누군가 스코프를 참조하고 있다면 스코프는 해제되지 않고 생존(24장에서 자세히!)
```
// 예제1
var x = 'global';

function foo() {
    console.log(x); // ㉠ undefined
    var x = 'local';
}

foo()

console.log(x); // global
```
 - 예제1에서 ㉠ 시점에 지역 변수 x는 이미 선언됨
    - *전역 변수는 전역 변수의 선언이 전역 스코프의 선두로 끌어올려진 것처럼, 지역변수는 지역 변수의 선언이 지역 스코프의 선두로 끌어올려진 것처럼 동작하기 떄문(호이스팅)*
- 따라서 전역 변수 x를 참조하는 것이 아니라 지역 변수 x를 참조하는데, 변수 할당문이 실행되기 이전까지는 undefined값을 가지므로 undefined가 출력되는 것

> 즉, 호이스팅은 변수 선언이 **스코프**의 선두로 끌어 올려진 것처럼 동작하는 js 고유의 특징

## :bulb: 전역 변수의 문제점
- :one: 암묵적 결합
    - 전역 변수는 코드 어디서든 참조하고 할당할 수 있음. 즉, 모든 코드가 전역 변수를 참조하고 변경할 수 있는 *암묵적 결합*을 허용하는 것
    - 변수의 유효 범위가 클수록 코드의 가독성 ↓, 위험성 ↑
- :two: 긴 생명 주기
    - 전역 변수는 생명 주기가 길어 메모리 리소스 과하게 소비
    - 특히 var 키워드는 변수의 중복 선언 허용하여 이름 중복 가능성 ↑ → **의도치 않은 재할당**
- :three: 스코프 체인 상 종점에 존재
    - 전역 변수는 스코프 체인 상 종점에 존재하여 변수 검색 시 가장 마지막에 검색, 즉 **전역 변수의 검색 속도가 가장 느림**
- :four: 네임스페이스 오염
    - js에서 다른 파일로 분리되어 있다 하더라도 하나의 전역 스코프를 공유
    - 다른 파일 내에서 동일한 이름의 전역 변수나 함수가 같은 스코프 내에 존재할 시 예상치 못한 결과 초래

## :bulb: 전역 변수 사용 억제 방법
> *변수의 스코프는 좁을수록 좋음*
- :one: 즉시 실행 함수
    ```
    (function() {
        var foo = 10; // 즉시 실행 함수의 지역 변수
    }());

    console.log(foo); // ReferenceError: foo is not defined
    ```
    - 모든 코드를 즉시 실행 함수로 감싸면 모든 변수는 즉시 실행 함수의 지역 변수
    - 단 한 번만 호출됨. 라이브러리 등에 자주 활용되는 방법

- :two: 네임스페이스 객체(유용:x:)
    ```
    var MYAPP = {}; // 전역 네임스페이스 객체

    MYAPP.name = 'Kim';

    console.log(MYAPP.name); // Kim
    ```
    - 전역에 네임스페이스 역할 담당할 객체 생성 후 전역 변수처럼 사용하고 싶은 변수를 프로퍼티로 추가하는 방법
    - 네임스페이스 객체에 또 다른 네임스페이스 객체를 추가하여 계층적으로 구성도 가능

- :three: 모듈 패턴
    ```
    var Counter = (function() {
        // private 변수
        var num = 0;

        // 외부로 공개할 데이터, 메서드를 프로퍼티로 추가한 객체 반환
        return {
            increase() {
                return ++num;
            },
            decrease() {
                return --num;
            }
        };
    }());

    // private 변수는 외부로 노출X
    console.log(Counter.num); // undefined

    console.log(Counter.increase()); // 1
    console.log(Counter.decrease()); // 0
    ```
    - 클래스를 모방하여 관련 있는 변수, 함수들을 모아 즉시 실행 함수로 감싸서 하나의 모듈 생성
        - js의 강력한 기능인 클로저를 기반으로 동작(24장에서 자세히!)
    - 모듈 패턴은 전역 변수 억제뿐 아니라 캡슐화도 가능
        - *캡슐화 encapsulation: 객체의 상태를 나타내는 프로퍼티, 프로퍼티를 참조 및 조작할 수 있는 동작인 메서드를 하나로 묶는 것*
    - 여느 OOP 언어와 달리 Js는 public, private, protected 등 접근 제한자를 제공하지 않으므로 모듈 패턴은 네임스페이스의 오염을 막는 기능과 더불어 **한정적인 정보 은닉을 구현하기 위해** 사용
- :four: ES6 모듈
    ```
    <script type="module" src="lib.mjs"></script>
    <script type="module" src="app.mjs"></script>
    ```
    - ES6 모듈을 사용하면 전역 변수를 사용할 수 없음
    - ES6 모듈은 파일 자체의 독자적 모듈 스코프를 제공