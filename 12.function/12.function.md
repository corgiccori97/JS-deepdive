## :bulb: 함수 리터럴

- 함수는 객체지만 일반 객체와는 다른 고유한 프로퍼티를 가지며 일반 객체와 다르게 **호출**할 수 있음


## :bulb: 함수 선언

:one: 함수 선언문

```
function add(x, y) {
    return x + y;
}
```

:two: 함수 표현식(권장)

```
var add = function (x, y) {
    return x + y;
};
```

:three: Function 생성자 함수(권장X)

```
var add = new Function('x', 'y', 'return x + y');
```

:four: 화살표 함수(ES6)

```
var add = (x, y) => x + y;
```

## :bulb: 함수 호이스팅
-  함수 선언문이 코드의 선두에 끌어올려진 것처럼 동작하는 js 고유의 특징
- 런타임 이전에 js 엔진에 의해 먼저 실행되어 식별자를 생성한다는 점에서 동일함
- **하지만**, var키워드로 선언된 변수는 undefined로 초기화되고 함수 선언문으로 암묵적으로 생성된 식별자는 함수 객체로 초기화됨  
    - 즉, **변수 선언문 이전에 변수를 참조하면 undefined로 평가, 함수 선언문 이전에 함수를 호출하면 호출 가능**
    - 함수 표현식은 변수에 할당되는 값이 함수 리터럴인 문 → 함수 표현식 = 변수 선언문 + 변수 할당문 → 변수 선언은 런타임 이전에 undefined로 초기화됨 → 변수 할당문의 값은 런타임에 평가되므로 함수 표현식의 함수 리터럴도 할당문이 실행되는 시점에 평가되어 함수 객체가 되는 것임
    - 따라서 함수 표현식으로 함수를 정의하면 함수 호이스팅이 아닌 변수 호이스팅이 발생
```
console.log(add(2, 5)); // 7
console.log(sub(2, 5)); // TypeError: sub is not a function

// 함수 선언문
function add (x, y) {
    return x + y;
}

// 함수 표현식
var sub = function (x, y) {
    return x - y;
};
```
- 함수 호이스팅은 함수 호출 전 함수를 선언해야 한다는 규칙을 무시하므로, 권장되지 않으며 함수 표현식을 사용할 것이 권장됨

## :bulb: 매개변수와 인수
- 자바스크립트 함수는 매개변수와 인수의 개수가 일치하는지 확인하지 않음
    - 인수가 적을 경우 undefined로, 인수가 넘칠 경우 무시
- 자바스크립트는 동적 타입 언어이므로 매개변수의 타입을 사전에 지정할 수 없음
    - :eight_spoked_asterisk: 함수를 정의할 때 적절한 인수가 전달되었는지 확인할 것!
    - 타입스크립트와 같은 정적 타입을 선언할 수 있는 자바스크립트의 상위 확장을 도입하여 컴파일 시점에 부적절한 호출 방지 가능