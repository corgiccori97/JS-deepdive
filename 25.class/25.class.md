## :bulb: 1. 클래스와 생성자 함수
:one: 클래스를 new 연산자 없이 호출하면 에러가 발생하지만 생성자 함수를 new 연산자 없이 호출할 경우 일반 함수로써 호출

:two: 클래스는 extends, super 키워드 제공

:three: 클래스는 호이스팅이 발생하지 않는 것처럼 동작하나 함수 선언문으로 정의된 생성자 함수는 함수 호이스팅이, 함수 표현식으로 정의한 생성자 함수는 변수 호이스팅 발생

:four: 클래스 내의 모든 코드에는 암묵적으로 strict mode 지정, 해제 불가능

:five: 클래스의 constructor, 프로토타입 메서드, 정적 메서드는 모두 프로퍼티 어트리뷰트 [[Enumerable]] 값이 false 즉 열거되지 않음

> 생성자 함수와 클래스는 프로토타입 기반 객체지향을 구현하였다는 점에서 매우 유사. 클래스의 extends, super 키워드는 상속 관계 구현을 간결하게 만들어 줌

## :bulb: 2. 클래스 정의
```
// 클래스 선언문
class Person {}

// 기명 클래스 표현식(익명으로도 가능)
const Person = class MyClass {};
```
- 클래스를 표현식으로 정의할 수 있다 === 클래스는 일급 객체이다
- 클래스 몸체에서 정의할 수 있는 메서드: **constructor(생성자), 프로토타입 메서드, 정적 메서드**
    ```
    // 예제2-1
    class Person {
        // 생성자
        constructor(name) {
            this.name = name;
        }

        // 프로토타입 메서드
        sayHi() {
            console.log(`Hi! my name is ${this.name}`);
        }

        // 정적 메서드
        static sayHello() {
            console.log('Hello!');
        }
    }

    const me = new Person('Kim'); 

    console.log(me.name); // Kim

    me.sayHi(); // Hi! my name is Kim
    Person.sayHello(); // Hello!
    ```

## :bulb: 3. 클래스 호이스팅
- 클래스 선언문으로 정의한 클래스는 함수 선언문과 같이 런타임 이전에 먼저 평가되어 함수 객체 생성
    - 클래스가 평가되어 생성된 함수 객체는 생성자 함수로써 호출할 수 있는 함수 즉 constructor

- 클래스는 클래스 정의 이전에 참고 불가능
    - **호이스팅이 발생하지 않는 것처럼 보이나, 클래스는 let, const 키워드처럼 호이스팅되어 클래스 선언문 이전에 일시적 사각지대TDZ에 빠짐**
        - :key: *"일시적 사각지대 Temporal Dead Zone; TDZ"*: let 키워드가 스코프 시작 지점부터 "초기화 단계" 까지 변수를 참조할 수 없는 구간`

## :bulb: 4. 인스턴스 생성
> 클래스는 인스턴스를 생성하는 것이 유일한 존재 이유이므로 반드시 new 연산자와 함께 호출
```

```