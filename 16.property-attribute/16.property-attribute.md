## :bulb: 내부 슬롯과 내부 메서드
> 내부 슬롯, 내부 메서드란 js 엔진의 구현 알고리즘을 설명하기 위해 ECMAScript 사양에서 사용하는 의사 프로퍼티 pseudo property와 의사 메서드 pseudo method 
- js 엔진의 내부 로직이므로 직접적으로 접근 및 호출은 불가
    - 단 일부 내부 슬롯과 내부 메서드에 한하여 간접적으로 접근할 수 있는 수단 제공
    - 예컨대 모든 객체는 [[Prototype]]이라는 내부 슬롯을 가지는데, 직접 접근할 수는 없지만 __proto__를 통해 간접적으로 접근 가능
    ```
    // 예제1
    const o = {};

    o.[[Prototype]] // Uncaught SyntaxError: Unexpected token '['

    o.__proto__ // Object.prototype
    ```
    - 예제1에서 [[Prototype]]같은 경우 내부 로직이므로 직접 접근 불가한 것을 확인할 수 있음

## :bulb: 프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체
> js 엔진은 프로퍼티 생성 시 프로퍼티의 상태인 '프로퍼티 어트리뷰트'를 기본값으로 자동 정의
>> 프로퍼티의 상태란?
>>> :one: 프로퍼티의 값 value

>>> :two: 값의 갱신 가능 여부 writable

>>> :three: 열거 가능 여부 enumerable

>>> :four: 재정의 가능 여부 configurable

```
// 예제2
const person = {
    name: 'kim'
};

console.log(Object.getOwnPropertyDescriptor(person, 'name')); 
// {value: 'kim', writable: true, enumerable: true, configurable: true}

person.age = 20;

console.log(Object.getOwnPropertyDescriptors(person)); // {name: {…}, age: {…}}
```
- *:eight_spoked_asterisk: 프로퍼티 어트리뷰트는 js 엔진이 관리하는 내부 상태 값 meta-property인 내부 슬롯 [[Value]], [[Writable]], [[Enumerable]], [[Configurable]]이므로 직접 접근할 수 없지만 Object.getOwnPropertyDescriptor 메서드를 활용하여 간접적으로 확인 가능*
    - Object.getOwnPropertyDescriptor는 프로퍼티가 존재할 경우 프로퍼티 어트리뷰트 정보를 제공하는 **프로퍼티 디스크립터 객체 PropertyDescriptor** , 존재하지 않으면 undefined 반환
    - 예제2에서 사용된 Object.getOwnPropertyDescriptor는 ES8에서 도입

## :bulb: 데이터 프로퍼티와 접근자 프로퍼티
> 프로퍼티는 **데이터 프로퍼티**(키와 값으로 구성된 일반적 프로퍼티), **접근자 프로퍼티**(자체적으로 값을 갖지 않고 다른 프로퍼티의 값을 읽거나 저장할 때 호출되는 접근자 함수로 구성)로 구분

<h3>

:tomato: **데이터 프로퍼티**

</h3>
데이터 프로퍼티가 갖는 프로퍼티 어트리뷰트는 js 엔진이 프로퍼티를 생성할 때 기본값으로 자동 정의

    1. [[Value]] : 반환되는 값
    2. [[Writable]] : 변경 가능 여부, boolean 값, false인 경우 읽기 전용 프로퍼티가 됨
    3. [[Enumerable]] : 열거 가능 여부, boolean 값, false인 경우 for문, Object.keys 메서드로 열거 불가능 
    4. [[Configurable]] : 재정의 가능 여부, boolean 값, false인 경우 해당 프로퍼티의 삭제, 프로퍼티 어트리뷰트 값 변경 금지, 단 [[Writable]]이 true인 경우 [[Value]] 변경과 [[Writable]]을 false로 변경하는 것은 허용

<h3>

:tomato: **접근자 프로퍼티**

</h3>
접근자 프로퍼티가 갖는 프로퍼티 어트리뷰트

    1. [[Get]] : 접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 !!읽을 때!! 호출되는 접근자 함수. 즉, 접근자 프로퍼티 키로 프로퍼티 값에 접근하면 프로퍼티 어트리뷰트 [[Get]]의 값 즉 getter 함수 호출
    2. [[Set]] : 접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 !!저장할 때!! 호출되는 접근자 함수. 즉, 접근자 프로퍼티 키로 프로퍼티 값을 저장하면 프로퍼티 어트리뷰트 [[Set]]의 값 즉 setter 함수 호출
    3. [[Enumerable]] : 데이터 프로퍼티와 동일
    4. [[Configurable]] : 데이터 프로퍼티와 동일

```
// 예제3 - 데이터 프로퍼티와 접근자 프로퍼티
const person2 = {
    firstName: 'Sanghee',
    lastName: 'Kim',

    // getter 함수
    get fullName() {
        return `${this.firstName} ${this.lastName}`;
    },

    // setter 함수
    set fullName(name) {
        [this.firstName, this.lastName] = name.split(' ');
    }
};

// 데이터 프로퍼티를 통한 프로퍼티 값 참조
console.log(person2.firstName + ' ' + person2.lastName); // Sanghee Kim

// 접근자 프로퍼티를 통한 프로퍼티 값 저장
// 접근자 프로퍼티 fullName에 값 저장하면 setter 함수 호출
person2.fullName = 'Heungmin Son';
console.log(person2); // {firstName: 'Heungmin', lastName: 'Son', fullName: <accessor>}

// 접근자 프로퍼티를 통한 프로퍼티 값 참조
// 접근자 프로퍼티 fullName에 접근하면 getter 함수 호출
console.log(person2.fullName); // Heungmin Son
```
- 예제3에서 firstName, lastName은 일반적인 데이터 프로퍼티
- 예제3에서 get, set이 붙은 메서드는 getter, setter 함수이며 getter/setter 함수의 이름 fullName이 접근자 프로퍼티
```
// 예제4 - 프로퍼티 디스크립터 객체 확인
let descriptor = Object.getOwnPropertyDescriptor(person2, 'firstName');
console.log(descriptor); 
// {value: 'Heungmin', writable: true, enumerable: true, configurable: true}

descriptor = Object.getOwnPropertyDescriptor(person2, 'fullName');
console.log(descriptor); 
// {get: ƒ, set: ƒ, enumerable: true, configurable: true}
```

- 예제4에서 firstName은 데이터 프로퍼티, fullName은 접근자 프로퍼티

## :bulb: 프로퍼티 정의
