## :bulb: 스코프란?

- 식별자가 유효한 범위
- js 엔진이 어떤 변수를 참조해야 할 지 결정할 때(식별자 결정 identifier resolution) 스코프를 사용. 즉 식별자란 js 엔진이 식별자를 검색할 때 사용하는 규칙
  >
      - var으로 선언된 변수는 같은 스코프 내에서 중복 선언이 허용 → 변수값이 재할당되어 변경되는 부작용 발생
      - let, const는 같은 스코프 내에서 중복 선언을 허용하지 않음

## :bulb: 스코프 체인

- 모든 스코프는 하나의 계층적 구조로 연결, 이를 스코프 체인이라 함
- 모든 지역 스코프의 최상위 스코프는 **전역 스코프**

:eight_spoked_asterisk: 변수를 참조할 때 js 엔진은 스코프 체인을 통해 참조하는 코드의 스코프에서 시작하여 상위 스코프 방향으로 이동하며 변수를 검색

## :bulb: 함수 레벨 스코프

- 블록 레벨 스코프 block level scope - 함수 몸체만이 아니라 모든 코드 블록(if, for, while, try/catch..)이 지역 스코프를 만드는 것(C, Java, let, const)
  > :star: _그러나_, var 키워드로 선언된 변수는 오로지 함수의 코드 블록(함수 몸체)만을 지역 스코프로 인정. 이를 **함수 레벨 스코프** 라고 함

```
// 예제1
var x = 1;

if (true) {
    var x = 10;
}

console.log(x); // 10
```

- 예제1에서, 전역 변수 x 선언
- if문 코드블록 내에서 선언된 x 변수도 전역 변수(var 키워드로 선언된 변수는 함수 레벨 스코프만 인정하기 때문)(**함수 밖에서 var 키워드로 선언된 변수는 코드 블록 내에서 선언되었다 할지라도 전역 변수다**)
- 이미 선언된 전역 변수 x가 있으므로 x는 중복 선언 → _의도치 않게 변수 값이 변경_

```
// 예제2
var i = 10;

for(var i = 0; i < 5; i++) {
    console.log(i); // 0 1 2 3 4
}

console.log(i); // 5
```

- 예제2에서 var키워드로 선언된 변수는 블록 레벨 스코프를 인정하지 않으므로 i라는 전역 변수가 중복 선언되고 *의도치 않은 전역 변수 값의 재할당*이 이루어짐

## :bulb: 렉시컬 스코프

```
var x2 = 1;

function foo2() {
    var x2 = 10;
    bar2();
}

function bar2() {
    console.log(x2);
}

foo2(); // ?
bar2(); // ?
```

- 마지막 결과는 어떻게 나올까? 
    - :one: 동적 스코프 dynamic scope: **함수를 어디서 호출했는지**에 따라 함수의 상위 스코프 결정

     - :two: :o:(Javascript):o:렉시컬 스코프 lexical scope / 정적 스코프 static scope: **함수를 어디서 정의했는지**에 따라 함수의 상위 스코프 결정

> js는 렉시컬 스코프를 따르므로 함수별 상위 스코프는 함수 정의가 실행될 때 정적으로 결정됨. 따라서 전역 변수 x2의 값 1을 두 번 출력
